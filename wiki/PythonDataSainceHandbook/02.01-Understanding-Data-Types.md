# 02.01 Handbook
## Понимание типов данных в Python
Эффективная наука и вычисления, основанные на данных, требуют понимания того, как данные хранятся и обрабатываются.
В этой главе описывается и сравнивается, как обрабатываются массивы данных в самом языке Python, а также как NumPy улучшает этот процесс.
Понимание этой разницы имеет основополагающее значение для понимания большей части материала всей остальной части книги.
Пользователей Python часто привлекает простота его использования, одним из элементов которой является динамическая типизация.
В то время как статически типизированный язык, такой как C или Java, требует явного объявления каждой переменной, динамически типизированный язык, такой как Python, пропускает эту спецификацию. Например, в C вы можете указать определенную операцию следующим образом:
```С
/* Code C */
result int = 0;
for (int i=0; i<100; i++){
    result += i;
}
```
В то время как на Python эквивалентную операцию можно записать следующим образом:
```Python
# Code Python
result = 0
for i in range(100):
    result += i
```
Обратите внимание на одно главное отличие: в C типы данных каждой переменной явно объявлены, тогда как в Python типы выводятся динамически. Это означает, например, что мы можем назначить любой тип данных любой переменной:
```Python
# Code Python
х = 4
х = "четыре"
```
Здесь мы переключили содержимое `x` с целого числа на строку. То же самое в C привело бы (в зависимости от настроек компилятора) к ошибке компиляции или другим непредвиденным последствиям:
```С
/* Код C */
целое число х = 4;
x = "четыре"; // НЕУДАЧНО
```
Такая гибкость — один из элементов, который делает Python и другие языки с динамической типизацией удобными и простыми в использовании.
Понимание того, *как* это работает, является важной частью обучения эффективному и действенному анализу данных с помощью Python.
Но эта гибкость типов также указывает на тот факт, что переменные Python — это не просто их значения; они также содержат дополнительную информацию о *типе* значения. Мы рассмотрим это подробнее в следующих разделах.
## Целое число в Python — это больше, чем просто целое число
Стандартная реализация Python написана на языке C.
Это означает, что каждый объект Python — это просто хитро замаскированная структура C, которая содержит не только свое значение, но и другую информацию. Например, когда мы определяем целое число в Python, например `x = 10000`, `x` — это не просто «сырое» целое число. На самом деле это указатель на составную структуру C, которая содержит несколько значений.
Просматривая исходный код Python 3.10, мы обнаруживаем, что определение типа integer (long) фактически выглядит следующим образом (после раскрытия макросов C):
```С
структура _longobject {
    длинный ob_refcnt;
    PyTypeObject *ob_type;
    размер_т об_размер;
    длинный ob_digit[1];
};
```
Одно целое число в Python 3.10 на самом деле состоит из четырех частей:
- `ob_refcnt`, счетчик ссылок, который помогает Python молча обрабатывать выделение и освобождение памяти
- `ob_type`, который кодирует тип переменной
- `ob_size`, который определяет размер следующих членов данных
- `ob_digit`, который содержит фактическое целочисленное значение, которое, как мы ожидаем, будет представлять переменная Python
Это означает, что при хранении целого числа в Python возникают некоторые накладные расходы по сравнению с компилируемым языком, таким как C, как показано на следующем рисунке:
![Целочисленная структура памяти](images/cint_vs_pyint.png)
Здесь `PyObject_HEAD` — это часть структуры, содержащая счетчик ссылок, код типа и другие части, упомянутые ранее.
Обратите внимание на разницу: целое число в языке C по сути является меткой позиции в памяти, байты которой кодируют целочисленное значение.
Целое число Python — это указатель на позицию в памяти, содержащую всю информацию об объекте Python, включая байты, содержащие целочисленное значение.
Эта дополнительная информация в целочисленной структуре Python позволяет программировать на Python так свободно и динамично.
Однако вся эта дополнительная информация в типах Python имеет свою цену, что становится особенно очевидным в структурах, объединяющих многие из этих объектов.
## Список Python — это больше, чем просто список
Давайте теперь рассмотрим, что происходит, когда мы используем структуру данных Python, содержащую множество объектов Python.
Стандартным изменяемым многоэлементным контейнером в Python является список.
Мы можем создать список целых чисел следующим образом:
```питон
L = список(диапазон(10))
Л
```
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```питон
тип(L[0])
```
    инт
Или, аналогично, список строк:
```питон
L2 = [str(c) для c в L]
Л2
```
    ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
```питон
тип(L2[0])
```
    ул
Благодаря динамической типизации Python мы можем даже создавать неоднородные списки:
```питон
L3 = [Верно, "2", 3.0, 4]
[тип(элемент) для элемента в L3]
```
    [логическое, строка, число с плавающей точкой, целое]
Но эта гибкость имеет свою цену: чтобы разрешить эти гибкие типы, каждый элемент в списке должен содержать свой собственный тип, количество ссылок и другую информацию. То есть каждый элемент является полным объектом Python.
В особом случае, когда все переменные имеют один и тот же тип, большая часть этой информации является избыточной, поэтому может быть гораздо эффективнее хранить данные в массиве фиксированного типа.
Разница между списком динамического типа и массивом фиксированного типа (в стиле NumPy) показана на следующем рисунке:
![Макет памяти массива](images/array_vs_list.png)
На уровне реализации массив по сути содержит один указатель на один непрерывный блок данных.
С другой стороны, список Python содержит указатель на блок указателей, каждый из которых, в свою очередь, указывает на полный объект Python, такой как целое число Python, которое мы видели ранее.
Опять же, преимуществом списка является гибкость: поскольку каждый элемент списка представляет собой полную структуру, содержащую как данные, так и информацию о типе, список можно заполнить данными любого желаемого типа.
Массивы фиксированного типа в стиле NumPy лишены такой гибкости, но гораздо более эффективны для хранения и обработки данных.
## Массивы фиксированного типа в Python
Python предлагает несколько различных вариантов хранения данных в эффективных буферах данных фиксированного типа.
Встроенный модуль `array` (доступен с Python 3.3) можно использовать для создания плотных массивов однородного типа:
```питон
импорт массива
L = список(диапазон(10))
A = массив.массив('i', L)
А
```
    массив('i', [0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
Здесь `'i'` — это код типа, указывающий, что содержимое представляет собой целые числа.
Однако гораздо более полезным является объект `ndarray` пакета NumPy.
В то время как объект `array` в Python обеспечивает эффективное хранение данных на основе массива, NumPy добавляет к этому эффективные *операции* с этими данными.
Мы рассмотрим эти операции в следующих главах; далее я покажу вам несколько различных способов создания массива NumPy.
## Создание массивов из списков Python
Начнем со стандартного импорта NumPy под псевдонимом `np`:
```питон
импортировать numpy как np
```
Теперь мы можем использовать `np.array` для создания массивов из списков Python:
```питон
# Целочисленный массив
np.массив([1, 4, 2, 5, 3])
```
    массив([1, 4, 2, 5, 3])
Помните, что в отличие от списков Python, массивы NumPy могут содержать данные только одного типа.
Если типы не совпадают, NumPy преобразует их в соответствии со своими правилами повышения типов; в данном случае целые числа преобразуются в числа с плавающей точкой:
```питон
np.массив([3.14, 4, 2, 3])
```
    массив([3.14, 4. , 2. , 3. ])
Если мы хотим явно задать тип данных результирующего массива, мы можем использовать ключевое слово `dtype`:
```питон
np.массив([1, 2, 3, 4], dtype=np.float32)
```
    массив([1., 2., 3., 4.], dtype=float32)
Наконец, в отличие от списков Python, которые всегда являются одномерными последовательностями, массивы NumPy могут быть многомерными. Вот один из способов инициализации многомерного массива с помощью списка списков:
```питон
# Вложенные списки приводят к многомерным массивам
np.array([range(i, i + 3) для i в [2, 4, 6]])
```
    массив([[2, 3, 4],
           [4, 5, 6],
           [6, 7, 8]])
Внутренние списки рассматриваются как строки результирующего двумерного массива.
## Создание массивов с нуля
Особенно для больших массивов эффективнее создавать массивы с нуля, используя встроенные в NumPy процедуры.
Вот несколько примеров:
```питон
# Создать массив целых чисел длиной 10, заполненный нулями
np.zeros(10, dtype=int)
```
    массив([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
```питон
# Создаем массив с плавающей точкой 3x5, заполненный единицами
np.ones((3, 5), dtype=float)
```
    массив([[1., 1., 1., 1., 1.],
           [1., 1., 1., 1., 1.],
           [1., 1., 1., 1., 1.]])
```питон
# Создаем массив 3x5, заполненный 3.14
нп.полный((3, 5), 3.14)
```
    массив([[3.14, 3.14, 3.14, 3.14, 3.14],
           [3.14, 3.14, 3.14, 3.14, 3.14],
           [3.14, 3.14, 3.14, 3.14, 3.14]])
```питон
# Создать массив, заполненный линейной последовательностью
# начиная с 0, заканчивая 20, с шагом 2
# (это похоже на встроенную функцию диапазона)
np.диапазон(0, 20, 2)
```
    массив([0, 2, 4, 6, 8, 10, 12, 14, 16, 18])
```питон
# Создайте массив из пяти значений, равномерно распределенных между 0 и 1
np.linspace(0, 1, 5)
```
    массив([0. , 0.25, 0.5 , 0.75, 1. ])
```питон
# Создаем массив 3x3 равномерно распределенных
# псевдослучайные значения от 0 до 1
нп.случайный.случайный((3, 3))
```
    массив([[0,09610171, 0,88193001, 0,70548015],
           [0,35885395, 0,91670468, 0,8721031],
           [0.73237865, 0.09708562, 0.52506779]])
```питон
# Создать массив 3x3 нормально распределенных псевдослучайных чисел
# значений со средним значением 0 и стандартным отклонением 1
np.случайный.нормальный(0, 1, (3, 3))
```
    массив([[-0,46652655, -0,59158776, -1,05392451],
           [-1,72634268, 0,03194069, -0,51048869],
           [ 1.41240208, 1.77734462, -0.43820037]])
```питон
# Создать массив 3x3 псевдослучайных целых чисел в интервале [0, 10)
np.random.randint(0, 10, (3, 3))
```
    массив([[4, 3, 8],
           [6, 5, 0],
           [1, 1, 4]])
```питон
# Создайте матрицу идентичности 3x3
нп.глаз(3)
```
    массив([[1., 0., 0.],
           [0., 1., 0.],
           [0., 0., 1.]])
```питон
# Создаем неинициализированный массив из трех целых чисел; значения будут
# что бы ни случилось, оно уже существует в этой ячейке памяти
нп.пусто(3)
```
    массив([1., 1., 1.])
## Стандартные типы данных NumPy
Массивы NumPy содержат значения одного типа, поэтому важно иметь подробные знания об этих типах и их ограничениях.
Поскольку NumPy написан на языке C, типы будут знакомы пользователям C, Fortran и других родственных языков.
Стандартные типы данных NumPy перечислены в следующей таблице.
Обратите внимание, что при построении массива их можно указать с помощью строки:
```питон
np.нули(10, dtype='int16')
```
Или с помощью связанного объекта NumPy:
```питон
np.нули(10, dtype=np.целое16)
```

| Тип данных | Описание |
|------------|-------------|
| `bool_` | Логическое значение (True или False), хранящееся в виде байта |
| `int_` | Целочисленный тип по умолчанию (такой же, как в C `long`; обычно `int64` или `int32`)|
| `intc` | Идентично C `int` (обычно `int32` или `int64`)|
| `intp` | Целое число, используемое для индексации (то же, что и `ssize_t` в C; обычно `int32` или `int64`)|
| `int8` | Байт (от –128 до 127)|
| `int16` | Целое число (от –32768 до 32767)|
| `int32` | Целое число (от –2147483648 до 2147483647)|
| `int64` | Целое число (от –9223372036854775808 до 9223372036854775807)|
| `uint8` | Беззнаковое целое число (от 0 до 255)|
| `uint16` | Беззнаковое целое число (от 0 до 65535)|
| `uint32` | Беззнаковое целое число (от 0 до 4294967295)|
| `uint64` | Беззнаковое целое число (от 0 до 18446744073709551615)|
| `float_` | Сокращение для `float64`|
| `float16` | Числа с плавающей точкой половинной точности: знаковый бит, 5 бит экспонента, 10 бит мантисса|
| `float32` | Плавающая точка одинарной точности: знаковый бит, 8 бит экспоненты, 23 бита мантиссы|
| `float64` | Плавающая точка двойной точности: знаковый бит, 11 бит экспонента, 52 бита мантисса|
| `complex_` | Сокращение для `complex128`|
| `complex64` | Комплексное число, представленное двумя 32-битными числами с плавающей точкой|
| `complex128`| Комплексное число, представленное двумя 64-битными числами с плавающей точкой|
