---
source: 'https://numpy.org/doc/stable/user/index.html'
author: null
created: {}
description: "NumPy\_(\_Numerical Python\_) — универсальный стандарт для работы с числовыми данными в Python, лежащий в основе научных экосистем Python и PyData."
tags: [Python, Program]
---

# NumPy
Библиотека NumPy содержит многомерные массивы и матричные структуры данных. NumPy можно использовать для выполнения множества математических операций с массивами. Он добавляет в Python мощные структуры данных, гарантирующие эффективные вычисления с массивами и матрицами, и предоставляет огромную библиотеку высокоуровневых математических функций, которые работают с этими массивами и матрицами.

## Начало
```python
pip install numpy # установка
import numpy as np # импорт
```

## Массивы в NumPy
Пример инициализации одномерного массива
```python
a = np.array([1, 2, 3, 4, 5, 6])
```
Обращение к элементам одномерного массива
```python
print(a[0])
```
Пример инициализации двумерного массива
```python
a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
```
*Для справки: Двумерный массив (он же матрица) - это одномерный массив, элементами которого являются одномерные массивы. Другими словами, это набор однотипных данных, имеющий общее имя, доступ к элементам которого осуществляется по двум индексам.*  
Двумерные массивы удобнее записывать так
```python
a = np.array([[1, 2, 3, 4],
              [5, 6, 7, 8], 
              [9, 10, 11, 12]])
```
При такой записи структура массива более понятна.  
Обращение к элементам двумерного массива немного отличается, и если мы напишем так
```python
print(a[0])
```
То мы получим: "\[1, 2, 3, 4\]", потому что это и есть первый элемент этого двумерного массива. А если нам надо обратится к конкретному значению, то мы должны использовать следующий код 
```python
print(a[1][2])
```
В этом случае будет выведено значение "7", находящееся во второй строке и третьем столбце матрицы. Для того что бы наглядно продемонстрировать, как это работает я написал такой код:
```python
#              0  1  2  3
a = np.array([[1, 2, 3, 4],     #0
              [5, 6, 7, 8],     #1
              [9, 10, 11, 12]]) #2
print(a[1][2])
```
Здесь под комментариями отмечены индексы элементов по строкам и столбцам. В обращении к конкретному элементу указывается сначала индекс строки, а потом столбца.  
Для **вывода массива** можно использовать команду *print.*
```python
a = np.array([[1, 2, 3, 4],     
              [5, 6, 7, 8],     
              [9, 10, 11, 12]]) 
print(a)
```
В этом случае массив будет выведен так же как и записан
```python
#Вывод кода выше:
[[ 1  2  3  4]
[ 5  6  7  8]
[ 9 10 11 12]]
```
Для "красивого" вывода этого массива поставьте "\*" перед именем массива.  
```python
print(*a)
```
В этом случае вывод всегда будет в строчку
```python
#Вывод:
[1 2 3 4] [5 6 7 8] [ 9 10 11 12]
```
## [Типы данных](Типы данных.md), которые поддерживает NumPy
## Атрибуты объекта ndarray
**a.ndim** - этот атрибут возвращает количество измерений массива.
```python
a = np.array([[1, 2, 3, 4],     
              [5, 6, 7, 8],     
              [9, 10, 11, 12]]) 
print(a.ndim)
#Вывод:
2
```
**a.shape** - возвращает кортеж, указывающий размер массива в каждом измерении.
```python
a = np.array([[1, 2, 3, 4],     
              [5, 6, 7, 8],     
              [9, 10, 11, 12]]) 
print(a.shape)
#Вывод:
(3, 4) #массив a имеет 3 строки и 4 столбца
```
**a.size** - возвращает общее число элементов массива (фактически это произведение элементов, возвращаемым **shape**) 
```python
a = np.array([[1, 2, 3, 4],     
              [5, 6, 7, 8],     
              [9, 10, 11, 12]]) 
print(a.size)
#Вывод:
12
```
**a.dtype** - возвращает тип элементов массива. Кроме стандартных типов, в NumPy есть собственные типы данных.
```python
a = np.array([[1, 2, 3, 4],     
              [5, 6, 7, 8],     
              [9, 10, 11, 12]]) 
print(a.dtype)
#Вывод:
int32
```
**a.diagonal()** - возвращает диагональ матрицы. В скобках можно указать индекс первого элемента диагонали (по умолчанию - 0). Пример:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/0f6/8d8/3f1/0f68d83f15adf0673b496476648762d6.png)

Я использовал квадратную матрицу, где число столбцов равно числу строк, но этот метод работает так же и с прямоугольными матрицами. Этот код вернёт:  *\[ 1.  6. 11.  6.\].* 

**a.sum()** - возвращает сумму всех элементов массива.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/989/e4e/c0f/989e4ec0f0fec5084acdf24407553f80.png)

К примеру этот код вернёт 78.0. Дополнительный 0 появляется потому что в массиве присутствуют дробные числа.

**a.mean()** - возвращает средне арифметическое всех элементов массива. Пример:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/873/23b/ae3/87323bae3fe8045fed3993515cc602ff.png)

Этот код вернёт 6.5

Кроме этого существуют функции **min()** и **max()**, которые возвращают минимальное и максимальное значение из элементов массива, а так же **argmin()** и **argmax()**, которые возвращают индексы наименьшего и наибольшего элементов массива соответственно.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/844/08e/70e/84408e70eaf5d26fb19ac16cd14539ad.png)

Это код вернёт 1.0 и 12.0.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/6cc/562/949/6cc5629491017b613538606d3b9a47bc.png)

А этот 0 и 11, именно такие индексы имеют элементы со значением 1 и 12.

## Основные функции NumPy
**np.zeros((n, m))** - создаёт массив размером n\*m, заполненный нулями. Из полезных дополнительных функций - после кортежа с размерностью массива вы можете указать тип элементов в массиве (это не обязательно, по умолчанию - *float64*). 
```python
import numpy as np
a = np.zeros((2, 4), int)
print(a)
#Вывод:
[[0 0 0 0]
 [0 0 0 0]]
```
**np.ones((n, m))** -  создаёт массив размером n\*m, заполненный единицами. Работает так же точно как и *np.zeros()*.
```python
import numpy as np
a = np.ones((2, 3))
print(a)
#Вывод:
[[1. 1. 1.]
 [1. 1. 1.]]
```
**np.empty((n, m))** - возвращает пустой (не инициализированный) массив размером n\*m. Он заполнен "мусором". Используя такие массивы будете осторожны, а лучше всегда задавайте начальные значения элементов массива. Атрибуты такие же как и у предыдущих функций.
```python
import numpy as np
a = np.empty((2, 3))
print(a)
```
Вывод на каждом компьютере каждый раз будет разным. *НЕ рекомендую использовать*. 
**np.copy(a)** - создаёт копию массива *a*. 
```python
import numpy as np
a = np.array([[1, 2, 3, 4.0],
[5, 6, 7, 8],
[9, 10, 11, 12]])
b = np.copy(a)
print(b)
#Вывод:
[[ 1.  2.  3.  4.]
 [ 5.  6.  7.  8.]
 [ 9. 10. 11. 12.]]
```
Кроме этого для создания копии массива мы можем использовать *np.array(a, copy=True)*.
```python
import numpy as np
a = np.array([[1, 2, 3, 4.0],
[5, 6, 7, 8],
[9, 10, 11, 12]])
b = np.array(a, copy=True)
print(b)
```
Вывод будет идентичен выводу предыдущего кода.
**np.eye(n)** - создаёт квадратную матрицу (параметр *n* - число столбцов = числу строк) с единицами на главной диагонали (от верхнего левого до нижнего правого угла), остальные позиции занимают нули. 
```python
import numpy as np
a = np.eye(7)
print(a)
#Вывод:
[[1. 0. 0. 0. 0. 0. 0.]
 [0. 1. 0. 0. 0. 0. 0.]
 [0. 0. 1. 0. 0. 0. 0.]
 [0. 0. 0. 1. 0. 0. 0.]
 [0. 0. 0. 0. 1. 0. 0.]
 [0. 0. 0. 0. 0. 1. 0.]
 [0. 0. 0. 0. 0. 0. 1.]]
```
Кстати, после параметра *n* вы так же можете указать тип данных.
**np.dot(a, b)** - скалярное произведение двух массивов. В коде его можно записывать по разному, например *a.dot(b)* или *a @ b* - тоже будут работать. 
```python
import numpy as np
a = np.array([[1, 2, 3, 4.0],
[5, 6, 7, 8],
[9, 10, 11, 12],
[3, 4, 5, 6]])
b = np.eye(4)
print(np.dot(a, b))
print(a.dot(b))
print(a @ b)
#Вывод:
[[ 1.  2.  3.  4.]
 [ 5.  6.  7.  8.]
 [ 9. 10. 11. 12.]
 [ 3.  4.  5.  6.]]
[[ 1.  2.  3.  4.]
 [ 5.  6.  7.  8.]
 [ 9. 10. 11. 12.]
 [ 3.  4.  5.  6.]]
[[ 1.  2.  3.  4.]
 [ 5.  6.  7.  8.]
 [ 9. 10. 11. 12.]
 [ 3.  4.  5.  6.]]
```
*Массив a - объявлен в коде, а массив b - это матрица с единицами на главной диагонали (она же единичная матрица).* Все эти строки кода выведут один и тот же результат.   
Кстати, хочу обратить ваше внимание на интересное свойство единичной матрицы. При умножении на неё массив не меняется, как например здесь, массив *a* после умножения на единичную матрицу *b* не изменился. Эта особенность используется достаточно часто, например в глубоком обучении. 
**np.prod(a)** - преумножение всех элементов в массиве. 
```python
print(np.prod(a))
#Вывод:
172440576000.0
```
**np.sin(), np.cos(), np.tan()** и т.д. - вернёт синус, косинус, тангенс и т.д. соответственно. Могут быть применены как к одному числу, так и к массиву с любым числом измерений.
```python
import numpy as np
a = np.array([[1, 20, 0, 6],
[5, 4, 7, 8.0],
[9, 0, 110,0],
[2, 4, 5, 6]])
print(np.sin(a))
print(np.cos(a))
print(np.tan(a))
print(np.sin(45))
print(np.cos(90))
print(np.tan(45))
```

Комментировать этот код я не буду, я думаю, что здесь всё и так понятно. Вот что этот код выведет (для удобства чтения между "принтами" я добавил пустую строку):

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/2c3/0b3/2e3/2c30b32e37ccdafbb89c6eaa9fd27df0.png)

Как мы видим все эти функции отлично работают и с массивами и с отдельными числами. 

np.sqrt() - возвращает квадратный корень числа или массива в скобках. Пример:

```python
import numpy as np
a = np.array([[1, 20, 0, 6],
[5, 4, 7, 8.0],
[9, 0, 110,0],
[2, 4, 5, 6]])
print(np.sqrt(a))
print(np.sqrt(25))
```

И, вывод этого кода:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/386/803/59b/38680359bb7d6a88e6c775890fcfdb81.png)

Все остальные функции для работы с массивами в общем то совпадают с обычными математическими операциями. В NumPy они выполняются поэлементно и каждую из них при желании можно заменить вложенными циклами. Далее я приведу таблицу доступных операций и примеры их использования.

| Операция | Описание |
| --- | --- |
| + | Сложение массивов или массива с числом |
| \- | Вычитание массивов или массива с числом, либо используется как унарный минус |
| \* | Умножение массивов или массива с числом |
| / | Деление массивов или массива с числом |
| // | Целочисленное деление массивов или массива с числом |
| \*\* | Возведение в степень (указывается или число или массив) |
| % | Вычисления остатка от деления (указывается или число или массив) |

```python
import numpy as np
a = np.array([[1, 2, 3, 4.0],
[5, 6, 7, 8],
[9, 10, 11, 12],
[3, 4, 5, 6]])
b = np.array([[2, 3, 5, 6],
[3, 2, 7, 9],
[2.3, 6, 6, 7.0101],
[2.5, 5, 4, 5.0]])
print(a + b)
print(a - b)
print(a * b)
print(a / b)
print(a // b)
print(a % b)
print(a ** 2)
```

Вы можете переписать этот код у себя и посмотреть вывод этого кода, я не стал помещать его сюда, так как он очень большой и не очень понятный с первого взгляда.

Кроме этого вы можете получить все уникальные элементы из массива, используя функцию **np.unique().** Пример её использования: 

```python
import numpy as np
b = np.array([[2, 3, 5, 6],
[3, 2, 7, 9],
[2.3, 6, 6, 7.0101],
[2.5, 5, 4, 5.0]])
print(np.unique(b))
```

Как видим, в массиве *b* имеются повторяющиеся элементы, после вызова функция выведет только уникальные, т.е.: 

*\[2.     2.3    2.5    3.     4.     5.     6.     7.     7.0101 9.    \]*

**Сортировка массива NumPy:**

**np.sort(a)** - эта функция возвращает отсортированную копию входного массива. Сам массив при этом не изменяется.

Давайте я покажу вам, как это работает, а заодно приведу пример работы с сортировкой:

```python
import numpy as np
a = np.array([[1, 20, 3, 6],
[5, 4, 7, 8],
[9, 10, 110, 12],
[2, 4, 5, 6]])
print(f"{a} \n")
print(np.sort(a))
print(f"\n {a} \n")
```

 \*Символы *\\n* означают перенос на следующую строку.

Вывод этого кода будет примерно таким:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/430/840/c4c/430840c4c2b5bbfe3ec823688c85b41e.png)

Как мы видим, первая строка *print(f"{a} \\n")* должна вывести оригинальный массив. Затем строка *print(np.sort(a))* выводит отсортированный  массив не изменяя его при этом. И в конце строка *print(f"\\n {a} \\n")* опять выводит оригинальный массив. Между выводами массивов проставлены пропуски строки для наглядности.

Кроме этого, обратите внимание на то, что массив сортируется построчно. Для того, что бы отсортировать его по "столбцам" необходимо указать параметр *0* через запятую, после названия массива. В этом случае код будет выглядеть так: 

```python
import numpy as np
a = np.array([[1, 20, 3, 6],
[5, 4, 7, 8],
[9, 10, 110, 12],
[2, 4, 5, 6]])
print(np.sort(a, 0))
```

И работать так:  

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/b5f/65c/77f/b5f65c77fabc8dd06071d6b28e414b98.png)

Если вы хотите отсортировать массив и при этом перезаписать его используя *np.sort()*, сделайте так:

```python
import numpy as np
a = np.array([[1, 20, 3, 6],
[5, 4, 7, 8],
[9, 10, 110, 12],
[2, 4, 5, 6]])
a = np.sort(a)
print(a)
```

В данном случае мы просто перезаписываем переменную. Вывод этого кода такой же как и в первом случае.

**np.argsort(a)** - возвращает как бы "массив с индексами", указывающий на то как был отсортирован массив. Пример использования:

```python
import numpy as np
a = np.array([[1, 20, 3, 6],
[5, 4, 7, 8],
[9, 10, 110, 12],
[2, 4, 5, 6]])
print(np.argsort(a))
print("")
print(a)
```

И вывод этого кода:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/6f6/1d9/61d/6f61d961dfc5faf2f0f6f458ddb0a588.png)

Здесь сначала выводится массив индексов, а затем оригинальный массив для сравнения. Что бы лучше разобраться с работой этого участка кода я рекомендую переписать его у себя и попробовать "поиграться" со значениями элементов массива.  

**Ещё некоторые функции:**

**np.random.random()** - возвращает массив чисел типа float в диапазоне от 0.0 до 1.0. На вход принимает длину списка. Пример использования:

```python
import numpy as np
print(np.random.random(6))
```

Вывод:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/27f/10e/061/27f10e06167ad815a4dad8380b1157b2.png)

**np.random.randint() -** возвращает случайное целое число в указанном диапазоне. Третьим параметром *size* можно передать длину возвращаемого массива. По умолчанию она равна 1. Пример использования: 

```python
import numpy as np
print(np.random.randint(0, 10, size=10))
```

Вывод:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/cc5/fa1/e4f/cc5fa1e4f5ac224718b039815fc29e3d.png)

**np.random.rand(n, m)** - принимает на вход два параметра и возвращает массив, заполненный случайными числами, размера n\*m. Пример:

```python
import numpy as np
print(np.random.rand(3, 3))
```

Вывод будет выглядеть примерно так:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/eb4/798/f77/eb4798f77a440258bba6e2b0b226f2f9.png)

**np.ramdom.normal(n, m, size=(x, y))** - возвращает выборку из нормального (гауссовского) распределения, где *n* \- "центр" распределения, *m* - отклонение, а кортеж в параметре *size* \- размеры возвращаемого массива *(x\*y)*. Пример использования: 

```lisp
import numpy as np
print(np.random.normal(1, 3, (3, 2)))
```

И вывод этого кода:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/aeb/dbe/c4c/aebdbec4ccec3b66868eed696a4701d8.png)

**np.arange(n, m, x)** - возвращает массив, где *n* - начало, *m* \- конец а *x* \- "шаг" между элементами массива. Пример:

```coffeescript
import numpy as np
print(np.arange(0, 25, 5))
```

Вывод:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/ef5/906/304/ef59063049d7e499abfd22effac980c0.png)

---
