---
source: 'https://numpy.org/doc/stable/user/index.html'
author: null
created: {}
description: "NumPy\_(\_Numerical Python\_) — универсальный стандарт для работы с числовыми данными в Python, лежащий в основе научных экосистем Python и PyData."
tags:
  - Python
  - Program
---

# NumPy
Библиотека NumPy содержит многомерные массивы и матричные структуры данных. NumPy можно использовать для выполнения множества математических операций с массивами. Он добавляет в Python мощные структуры данных, гарантирующие эффективные вычисления с массивами и матрицами, и предоставляет огромную библиотеку высокоуровневых математических функций, которые работают с этими массивами и матрицами.

## Начало
```python
pip install numpy # установка
import numpy as np # импорт
```

## Массивы в NumPy

**Пример инициализации одномерного массива:**

```python
a = np.array([1, 2, 3, 4, 5, 6])
```

Обращение к элементам одномерного массива: 

```python
print(a[0])
```

Этот код выведет первый элемент массива, в данном случае "1".

**Пример инициализации двумерного массива:**

```python
a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
```

Для справки: **Двумерный массив** (он же матрица) - это одномерный массив, элементами которого являются одномерные массивы. Другими словами, это набор однотипных данных, имеющий общее имя, доступ к элементам которого осуществляется по двум индексам.

Двумерные массивы удобнее записывать так:

```python
a = np.array([[1, 2, 3, 4],
              [5, 6, 7, 8], 
              [9, 10, 11, 12]])
```

При такой записи структура массива более понятна.

Обращение к элементам двумерного массива немного отличается, и если мы напишем так:

```python
print(a[0])
```

То мы получим: "\[1, 2, 3, 4\]", потому что это и есть первый элемент этого двумерного массива. А если нам надо обратится к конкретному значению, то мы должны использовать следующий код: 

```markdown
print(a[1][2])
```

В этом случае будет выведено значение "7", находящееся во второй строке и третьем столбце матрицы. Для того что бы наглядно продемонстрировать, как это работает я написал такой код:

```python
#              0  1  2  3
a = np.array([[1, 2, 3, 4],     #0
              [5, 6, 7, 8],     #1
              [9, 10, 11, 12]]) #2
print(a[1][2])
```

Здесь под комментариями отмечены индексы элементов по строкам и столбцам. В обращении к конкретному элементу указывается сначала индекс строки, а потом столбца.

Для **вывода массива** можно использовать команду *print.*

```python
a = np.array([[1, 2, 3, 4],     
              [5, 6, 7, 8],     
              [9, 10, 11, 12]]) 
print(a)
```

В этом случае массив будет выведен так же как и записан:

```python
#Вывод кода выше:
[[ 1  2  3  4]
[ 5  6  7  8]
[ 9 10 11 12]]
```

Для "красивого" вывода этого массива поставьте "\*" перед именем массива. Вот так: 

```python
print(*a)
```

 В этом случае вывод всегда будет в строчку:

```python
#Вывод:
[1 2 3 4] [5 6 7 8] [ 9 10 11 12]
```

### Немного о [[Типы данных|типах данных]], которые поддерживает NumPy

**Наиболее важными атрибутами объекта ndarray являются:**

**a.ndim** - этот атрибут возвращает количество измерений массива.

Например такой код:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/46c/1df/dca/46c1dfdcab6b97a8003747d6af138a43.png)

Вернёт *2*, так как массив, который объявлен первым двумерный, и *1*, так как массив, который объявлен вторым одномерный. 

**a.shape** - возвращает кортеж, указывающий размер массива в каждом измерении.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/a1e/b1b/062/a1eb1b062581bd33881984061dc26bc2.png)

Код из примера выше вернёт *(3, 4)*так как массив a имеет 3 строки и 4 столбца.

**a.size** \- возвращает общее число элементов массива (фактически это произведение элементов, возвращаемым **shape**) 

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/609/d04/43a/609d0443ae7bb098cf82e838133b1897.png)

Как уже говорилось ранее код выше вернёт *12.*

**a.dtype** - возвращает тип элементов массива. Кроме стандартных типов, в NumPy есть собственные типы данных. Об основных типах данных в NymPy мы поговорим в следующем шаге.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/b3e/e87/7dc/b3ee877dc660b1eda7623493ab9aeb2e.png)

Обратите внимание на то, что этот код вернёт тип *int32* (один из собственных типов NumPy), но если мы добавим в массив хотя-бы одно число с плавающей точкой, как здесь: 

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/368/8dc/750/3688dc750cd8752d00b0cb4d58863d65.png)

\*обратите внимание на элемент в конце первой строки

В этом случае вывод будет *float64,* так как число 4.0 - относится к типу float. 

**a.itemsize** - возвращает максимальный размер одного элемента в массиве в байтах. Для массива типа *int32* вывод будет *4*, а для массива типа *float64 - 8.*

Вот пара примеров:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/3d2/510/6ea/3d25106ea2bda42749a59707602a0ef0.png)

Здесь массив *a* имеет тип  *int32,* так как все элементы массива - целые числа. Вывод этой программы будет *4*.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/883/2d0/71b/8832d071b30203edd8fb3812872d30c2.png)

Вывод этого кода будет *8*, так как имеет один элемент типа float, а это значит что тип массива - *float64.* 

**a.diagonal()** - возвращает диагональ матрицы. В скобках можно указать индекс первого элемента диагонали (по умолчанию - 0). Пример:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/0f6/8d8/3f1/0f68d83f15adf0673b496476648762d6.png)

Я использовал квадратную матрицу, где число столбцов равно числу строк, но этот метод работает так же и с прямоугольными матрицами. Этот код вернёт:  *\[ 1.  6. 11.  6.\].* 

**a.sum()** - возвращает сумму всех элементов массива.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/989/e4e/c0f/989e4ec0f0fec5084acdf24407553f80.png)

К примеру этот код вернёт 78.0. Дополнительный 0 появляется потому что в массиве присутствуют дробные числа.

**a.mean()** - возвращает средне арифметическое всех элементов массива. Пример:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/873/23b/ae3/87323bae3fe8045fed3993515cc602ff.png)

Этот код вернёт 6.5

Кроме этого существуют функции **min()** и **max()**, которые возвращают минимальное и максимальное значение из элементов массива, а так же **argmin()** и **argmax()**, которые возвращают индексы наименьшего и наибольшего элементов массива соответственно.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/844/08e/70e/84408e70eaf5d26fb19ac16cd14539ad.png)

Это код вернёт 1.0 и 12.0.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/6cc/562/949/6cc5629491017b613538606d3b9a47bc.png)

А этот 0 и 11, именно такие индексы имеют элементы со значением 1 и 12.

## Основные функции NumPy

**np.zeros((n, m))** - создаёт массив размером n\*m, заполненный нулями. Из полезных дополнительных функций - после кортежа с размерностью массива вы можете указать тип элементов в массиве (это не обязательно, по умолчанию - *float64*). Пример использования: 

```python
import numpy as np
a = np.zeros((2, 4), int)
print(a)
```

Этот код выведет такой массив: 

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/4f9/8cf/898/4f98cf8980724f993410cadf7686e87c.png)

Если бы я не указал тип данных или указал бы *float* он выглядел бы так:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/b5f/b56/c98/b5fb56c9866999d53e9efce9c7304a6a.png)

Здесь нули после точки просто "опущены".

**np.ones((n, m))** -  создаёт массив размером n\*m, заполненный единицами. Работает так же точно как и *np.zeros()*. Пример:

```python
import numpy as np
a = np.ones((2, 3))
print(a)
```

Код выведет такую матрицу:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/9e3/bcc/27f/9e3bcc27f735e3e47ba79f962bd52e01.png)

**np.empty((n, m))** - возвращает пустой (не инициализированный) массив размером n\*m. Он заполнен "мусором". Используя такие массивы будете осторожны, а лучше всегда задавайте начальные значения элементов массива. Атрибуты такие же как и у предыдущих функций.

Использование: 

```python
import numpy as np
a = np.empty((2, 3))
print(a)
```

Вывод (на каждом компьютере каждый раз будет разным):

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/5e7/1e3/135/5e71e3135d9a2492d08d62ed7069272c.png)

Ещё раз повторю: *НЕ рекомендую использовать*. 

**np.copy(a)** - создаёт копию массива *a*. Применение:

```python
import numpy as np
a = np.array([[1, 2, 3, 4.0],
[5, 6, 7, 8],
[9, 10, 11, 12]])
b = np.copy(a)
print(b)
```

Вывод это программы будет такой:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/bbf/c19/360/bbfc19360e12c01e30fcadfeef6cb0c6.png)

Кроме этого для создания копии массива мы можем использовать *np.array(a, copy=True).* Это будет так:

```python
import numpy as np
a = np.array([[1, 2, 3, 4.0],
[5, 6, 7, 8],
[9, 10, 11, 12]])
b = np.array(a, copy=True)
print(b)
```

Вывод будет идентичен выводу предыдущего кода.

**np.eye(n)** - создаёт квадратную матрицу (параметр *n* - число столбцов = числу строк) с единицами на главной диагонали (от верхнего левого до нижнего правого угла), остальные позиции занимают нули. 

Вы можете использовать это примерно так:

```python
import numpy as np
a = np.eye(4)
print(a)
```

В этом случае вы получите такой ответ:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/602/24c/42a/60224c42ace707f61ccc3cc68d84eca5.png)

Кстати, после параметра *n* вы так же можете указать тип данных.

**np.dot(a, b)** - скалярное произведение двух массивов. В коде его можно записывать по разному, например *a.dot(b)* или *a @ b* - тоже будут работать. Пример: 

*\*для демонстрации работы этой функции я использую другой набор массивов, нежели чем у остальных (так надо, потом поймёте)*

```python
import numpy as np
a = np.array([[1, 2, 3, 4.0],
[5, 6, 7, 8],
[9, 10, 11, 12],
[3, 4, 5, 6]])
b = np.eye(4)
print(np.dot(a, b))
print(a.dot(b))
print(a @ b)
```

*Массив a - объявлен в коде, а массив b - это матрица с единицами на главной диагонали (она же единичная матрица).*

Все эти строки кода выведут один и тот же результат: 

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/102/d18/acd/102d18acd9ec27ac78c9ae3725aa55c2.png)

Кстати, хочу обратить ваше внимание на интересное свойство единичной матрицы. При умножении на неё массив не меняется, как например здесь, массив *a* после умножения на единичную матрицу *b* не изменился. Эта особенность используется достаточно часто, например в глубоком обучении. 

**np.prod(a)** - преумножение всех элементов в массиве.  Пример использования:

```lisp
print(np.prod(a))
```

Этот код вернёт: 

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/855/91f/a83/85591fa835e70fa55252743261a98456.png)

**np.sin(), np.cos(), np.tan()** и т.д. - вернёт синус, косинус, тангенс и т.д. соответственно. Могут быть применены как к одному числу, так и к массиву с любым числом измерений. Пример:

```python
import numpy as np
a = np.array([[1, 20, 0, 6],
[5, 4, 7, 8.0],
[9, 0, 110,0],
[2, 4, 5, 6]])
print(np.sin(a))
print(np.cos(a))
print(np.tan(a))
print(np.sin(45))
print(np.cos(90))
print(np.tan(45))
```

Комментировать этот код я не буду, я думаю, что здесь всё и так понятно. Вот что этот код выведет (для удобства чтения между "принтами" я добавил пустую строку):

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/2c3/0b3/2e3/2c30b32e37ccdafbb89c6eaa9fd27df0.png)

Как мы видим все эти функции отлично работают и с массивами и с отдельными числами. 

np.sqrt() - возвращает квадратный корень числа или массива в скобках. Пример:

```python
import numpy as np
a = np.array([[1, 20, 0, 6],
[5, 4, 7, 8.0],
[9, 0, 110,0],
[2, 4, 5, 6]])
print(np.sqrt(a))
print(np.sqrt(25))
```

И, вывод этого кода:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/386/803/59b/38680359bb7d6a88e6c775890fcfdb81.png)

Все остальные функции для работы с массивами в общем то совпадают с обычными математическими операциями. В NumPy они выполняются поэлементно и каждую из них при желании можно заменить вложенными циклами. Далее я приведу таблицу доступных операций и примеры их использования.

| Операция | Описание |
| --- | --- |
| + | Сложение массивов или массива с числом |
| \- | Вычитание массивов или массива с числом, либо используется как унарный минус |
| \* | Умножение массивов или массива с числом |
| / | Деление массивов или массива с числом |
| // | Целочисленное деление массивов или массива с числом |
| \*\* | Возведение в степень (указывается или число или массив) |
| % | Вычисления остатка от деления (указывается или число или массив) |

```python
import numpy as np
a = np.array([[1, 2, 3, 4.0],
[5, 6, 7, 8],
[9, 10, 11, 12],
[3, 4, 5, 6]])
b = np.array([[2, 3, 5, 6],
[3, 2, 7, 9],
[2.3, 6, 6, 7.0101],
[2.5, 5, 4, 5.0]])
print(a + b)
print(a - b)
print(a * b)
print(a / b)
print(a // b)
print(a % b)
print(a ** 2)
```

Вы можете переписать этот код у себя и посмотреть вывод этого кода, я не стал помещать его сюда, так как он очень большой и не очень понятный с первого взгляда.

Кроме этого вы можете получить все уникальные элементы из массива, используя функцию **np.unique().** Пример её использования: 

```python
import numpy as np
b = np.array([[2, 3, 5, 6],
[3, 2, 7, 9],
[2.3, 6, 6, 7.0101],
[2.5, 5, 4, 5.0]])
print(np.unique(b))
```

Как видим, в массиве *b* имеются повторяющиеся элементы, после вызова функция выведет только уникальные, т.е.: 

*\[2.     2.3    2.5    3.     4.     5.     6.     7.     7.0101 9.    \]*

**Сортировка массива NumPy:**

**np.sort(a)** - эта функция возвращает отсортированную копию входного массива. Сам массив при этом не изменяется.

Давайте я покажу вам, как это работает, а заодно приведу пример работы с сортировкой:

```python
import numpy as np
a = np.array([[1, 20, 3, 6],
[5, 4, 7, 8],
[9, 10, 110, 12],
[2, 4, 5, 6]])
print(f"{a} \n")
print(np.sort(a))
print(f"\n {a} \n")
```

 \*Символы *\\n* означают перенос на следующую строку.

Вывод этого кода будет примерно таким:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/430/840/c4c/430840c4c2b5bbfe3ec823688c85b41e.png)

Как мы видим, первая строка *print(f"{a} \\n")* должна вывести оригинальный массив. Затем строка *print(np.sort(a))* выводит отсортированный  массив не изменяя его при этом. И в конце строка *print(f"\\n {a} \\n")* опять выводит оригинальный массив. Между выводами массивов проставлены пропуски строки для наглядности.

Кроме этого, обратите внимание на то, что массив сортируется построчно. Для того, что бы отсортировать его по "столбцам" необходимо указать параметр *0* через запятую, после названия массива. В этом случае код будет выглядеть так: 

```python
import numpy as np
a = np.array([[1, 20, 3, 6],
[5, 4, 7, 8],
[9, 10, 110, 12],
[2, 4, 5, 6]])
print(np.sort(a, 0))
```

И работать так:  

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/b5f/65c/77f/b5f65c77fabc8dd06071d6b28e414b98.png)

Если вы хотите отсортировать массив и при этом перезаписать его используя *np.sort()*, сделайте так:

```python
import numpy as np
a = np.array([[1, 20, 3, 6],
[5, 4, 7, 8],
[9, 10, 110, 12],
[2, 4, 5, 6]])
a = np.sort(a)
print(a)
```

В данном случае мы просто перезаписываем переменную. Вывод этого кода такой же как и в первом случае.

**np.argsort(a)** - возвращает как бы "массив с индексами", указывающий на то как был отсортирован массив. Пример использования:

```python
import numpy as np
a = np.array([[1, 20, 3, 6],
[5, 4, 7, 8],
[9, 10, 110, 12],
[2, 4, 5, 6]])
print(np.argsort(a))
print("")
print(a)
```

И вывод этого кода:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/6f6/1d9/61d/6f61d961dfc5faf2f0f6f458ddb0a588.png)

Здесь сначала выводится массив индексов, а затем оригинальный массив для сравнения. Что бы лучше разобраться с работой этого участка кода я рекомендую переписать его у себя и попробовать "поиграться" со значениями элементов массива.  

**Ещё некоторые функции:**

**np.random.random()** - возвращает массив чисел типа float в диапазоне от 0.0 до 1.0. На вход принимает длину списка. Пример использования:

```python
import numpy as np
print(np.random.random(6))
```

Вывод:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/27f/10e/061/27f10e06167ad815a4dad8380b1157b2.png)

**np.random.randint() -** возвращает случайное целое число в указанном диапазоне. Третьим параметром *size* можно передать длину возвращаемого массива. По умолчанию она равна 1. Пример использования: 

```python
import numpy as np
print(np.random.randint(0, 10, size=10))
```

Вывод:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/cc5/fa1/e4f/cc5fa1e4f5ac224718b039815fc29e3d.png)

**np.random.rand(n, m)** - принимает на вход два параметра и возвращает массив, заполненный случайными числами, размера n\*m. Пример:

```python
import numpy as np
print(np.random.rand(3, 3))
```

Вывод будет выглядеть примерно так:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/eb4/798/f77/eb4798f77a440258bba6e2b0b226f2f9.png)

**np.ramdom.normal(n, m, size=(x, y))** - возвращает выборку из нормального (гауссовского) распределения, где *n* \- "центр" распределения, *m* - отклонение, а кортеж в параметре *size* \- размеры возвращаемого массива *(x\*y)*. Пример использования: 

```lisp
import numpy as np
print(np.random.normal(1, 3, (3, 2)))
```

И вывод этого кода:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/aeb/dbe/c4c/aebdbec4ccec3b66868eed696a4701d8.png)

**np.arange(n, m, x)** - возвращает массив, где *n* - начало, *m* \- конец а *x* \- "шаг" между элементами массива. Пример:

```coffeescript
import numpy as np
print(np.arange(0, 25, 5))
```

Вывод:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/ef5/906/304/ef59063049d7e499abfd22effac980c0.png)

---

На этом статья подошла к концу. Если я что-то забыл или где-то ошибся - пишите в комментарии или ЛС.

### От автора:

Спасибо, что дочитали статью до конца, надеюсь она была вам полезна и сэкономила вам время. Если хотите повлиять на выход дальнейших статей, то можете подписаться на мой [telegram-канал](https://t.me/yarikGU_off), там в том числе будут опросы касаемо выходов новых статей а так же разнообразные интересные материалы (это статья в pdf там тоже будет). Если хотите со мной связаться или предложить тему для статьи - мои контакты есть на [сайте](https://y-a-r-i-k.github.io/).

Ещё раз спасибо, что дочитали до сюда!

**Удачи!**

Если эта публикация вас вдохновила и вы хотите поддержать автора — не стесняйтесь нажать на кнопку
