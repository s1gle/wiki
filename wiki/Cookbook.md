# Cookbook IPython
:hammer: :blue_book: :green_apple:
## 1.2. Начало работы с исследовательским анализом данных в Jupyter Notebook
1.  Самый первый шаг — импортировать научные пакеты, которые мы будем использовать в этом рецепте, а именно NumPy, pandas и matplotlib. Мы также указываем matplotlib отображать фигуры как встроенные изображения в Notebook:

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
%matplotlib inline
```
2.  Теперь мы создаем новую переменную Python с именем url, которая содержит адрес файла данных CSV (значения, разделенные запятыми) . Этот стандартный текстовый формат файла используется для хранения табличных данных:

```python
url = ("https://raw.githubusercontent.com/"
       "ipython-books/cookbook-2nd-data/"
       "master/bikes.csv")
```
```python
import pyodide_http
pyodide_http.patch_all()
```

3.  pandas определяет read_csv()функцию, которая может читать любой CSV-файл. Здесь мы передаем URL-адрес файла. pandas автоматически загрузит файл, проанализирует его и вернет DataFrameобъект. Нам нужно указать несколько параметров, чтобы убедиться, что даты анализируются правильно:

```python
df = pd.read_csv(url, index_col='Date',
                 parse_dates=True, dayfirst=True, encoding='utf-8')
```

5.  Мы можем получить некоторую сводную статистику таблицы с помощью describe()метода:

```python
df.describe()
```

6.  Давайте отобразим некоторые цифры. Мы построим график ежедневной посещаемости двух треков. Сначала мы выбираем два столбца, Berri1и PierDup. Затем мы вызываем plot()метод:

```python
df[['Berri1', 'PierDup']].plot(figsize=(10, 6),
                               style=['-', '--'],
                               lw=2)
```

7.  Теперь перейдем к немного более продвинутому анализу. Мы рассмотрим посещаемость всех треков как функцию дня недели. Мы можем легко получить день недели с помощью pandas: indexатрибут объекта DataFrameсодержит даты всех строк в таблице. Этот индекс имеет несколько атрибутов, связанных с датами, включая weekday_name:

```python
df.index.weekday
```

8.  Чтобы получить посещаемость как функцию дня недели, нам нужно сгруппировать элементы таблицы по дню недели. groupby()Метод позволяет нам сделать именно это. Мы используем weekdayвместо weekday_nameдля сохранения порядка дней недели (понедельник — 0, вторник — 1 и т. д.). После группировки мы можем суммировать все строки в каждой группе:

```python
df_week = df.groupby(df.index.weekday).sum()
df_week
```

9.  Теперь мы можем отобразить эту информацию на рисунке. Мы создаем рисунок matplotlib и используем plot()метод a DataFrameдля создания нашего графика:

```python
fig, ax = plt.subplots(1, 1, figsize=(10, 8))
df_week.plot(style='-o', lw=3, ax=ax)
ax.set_xlabel('Weekday')
# We replace the labels 0, 1, 2... by the weekday
# names.
ax.set_xticklabels(
    ('Monday,Tuesday,Wednesday,Thursday,'
     'Friday,Saturday,Sunday').split(','))
ax.set_ylim(0)  # Set the bottom axis to 0.
```

10.  Наконец, давайте проиллюстрируем интерактивные возможности Notebook. Мы построим сглаженную версию посещаемости трека как функцию времени ( скользящее среднее ). Идея состоит в том, чтобы вычислить среднее значение в окрестности любого дня. Чем больше окрестности, тем более плавная кривая. Мы создадим интерактивный ползунок в Notebook, чтобы изменять этот параметр в реальном времени на графике. Все, что нам нужно сделать, это добавить @interactдекоратор над нашей функцией построения графика:

```python
import micropip

await micropip.install('ipywidgets')
```

```python
from ipywidgets import interact

@interact
def plot(n=(1, 30)):
    fig, ax = plt.subplots(1, 1, figsize=(10, 8))
    df['Berri1'].rolling(window=n).mean().plot(ax=ax)
    ax.set_ylim(0, 7000)
    plt.show()
```

## 1.3. Знакомство с многомерным массивом в NumPy для быстрых вычислений массивов

1.  Импортируем встроенный randomмодуль Python и NumPy:

2.  Мы генерируем два списка Python, xи y, каждый из которых содержит 1 миллион случайных чисел от 0 до 1:

```python
n = 1000000
x = [random.random() for _ in range(n)]
y = [random.random() for _ in range(n)]

x[:3], y[:3]
```

3.  Давайте вычислим поэлементную сумму всех этих чисел: первый элемент xплюс первый элемент yи т. д. Мы используем forцикл в представлении списка:

```python
z = [x[i] + y[i] for i in range(n)]
z[:3]
```

4.  Сколько времени занимает это вычисление? IPython определяет удобную %timeitмагическую команду для быстрой оценки времени, затраченного на выполнение одного оператора:

```python
%timeit [x[i] + y[i] for i in range(n)]
```

5.  Теперь мы выполним ту же операцию с NumPy. NumPy работает с многомерными массивами, поэтому нам нужно преобразовать наши списки в массивы. Функция np.array()делает именно это:

```python
xa = np.array(x)
ya = np.array(y)
xa[:3]
```

Массивы xaи yaсодержат те же самые числа, что и наши исходные списки xи y. Эти списки были экземплярами listвстроенного класса, в то время как наши массивы являются экземплярами ndarrayкласса NumPy. Эти типы реализованы в Python и NumPy совершенно по-разному. В этом примере мы увидим, что использование массивов вместо списков приводит к радикальному повышению производительности.

6.  Чтобы вычислить поэлементную сумму этих массивов, нам forбольше не нужно делать цикл. В NumPy сложение двух массивов означает покомпонентное сложение элементов массивов. Это стандартная математическая нотация в линейной алгебре (операции над векторами и матрицами):